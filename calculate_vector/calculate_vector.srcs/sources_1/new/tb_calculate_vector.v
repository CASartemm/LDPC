module tb_calculate_vector;  // Определение модуля тестбенча для проверки calculate_vector

    // Сигналы для тестирования
    reg aclk;                     // Регистр для тактового сигнала (clock)
    reg aresetn;                  // Регистр для сигнала сброса (reset, active low)
    reg s_axis_tdata;             // Регистр для 1-битных входных данных по AXI-Stream интерфейсу
    reg s_axis_tvalid;            // Регистр для сигнала валидности входных данных
    reg s_axis_tlast;             // Регистр для сигнала последнего пакета входных данных
    wire s_axis_tready;           // Провод для сигнала готовности приема входных данных от DUT

    wire m_axis_tdata;            // Провод для 1-битных выходных данных по AXI-Stream интерфейсу
    wire m_axis_tvalid;           // Провод для сигнала валидности выходных данных
    reg  m_axis_tready;           // Регистр для сигнала готовности приема выходных данных
    wire m_axis_tlast;            // Провод для сигнала последнего пакета выходных данных

    // Переменные и массивы
    reg [639:0] bit_sequence;     // Регистр для хранения 640-битной входной последовательности данных
    reg [127:0] expected_result_bits;  // Регистр для хранения 128-битного эталонного результата в прямом порядке
    reg [127:0] received_result;  // Регистр для хранения полученного результата от DUT
    integer i;                    // Целочисленная переменная для использования в циклах как счетчик
    integer bit_count;            // Целочисленная переменная для подсчета полученных битов на выходе
    integer fd;                   // Целочисленная переменная для дескриптора файла
    integer char;                 // Целочисленная переменная для хранения прочитанного символа из файла
    integer test_num;             // Целочисленная переменная для номера текущего теста
    reg [767:0] bits;             // Регистр для временного хранения 768 битов (640 вход + 128 эталон)
    integer bit_idx;              // Целочисленная переменная для индекса в массиве bits
    reg end_of_file;              // Регистр для флага, указывающего на конец файла
    integer success_count;        // Целочисленная переменная для подсчета успешных тестов
    integer fail_count;           // Целочисленная переменная для подсчета неуспешных тестов

    // Подключение DUT (Device Under Test)
    calculate_vector dut (        // Инстанцирование модуля calculate_vector как DUT
        .aclk(aclk),              // Подключение тактового сигнала к DUT
        .aresetn(aresetn),        // Подключение сигнала сброса к DUT
        .s_axis_tdata(s_axis_tdata),  // Подключение входных данных к DUT
        .s_axis_tvalid(s_axis_tvalid),// Подключение сигнала валидности входа к DUT
        .s_axis_tready(s_axis_tready),// Подключение сигнала готовности от DUT
        .s_axis_tlast(s_axis_tlast),  // Подключение сигнала последнего пакета входа к DUT
        .m_axis_tdata(m_axis_tdata),  // Подключение выходных данных от DUT
        .m_axis_tvalid(m_axis_tvalid),// Подключение сигнала валидности выхода от DUT
        .m_axis_tready(m_axis_tready),// Подключение сигнала готовности приема выхода к DUT
        .m_axis_tlast(m_axis_tlast)   // Подключение сигнала последнего пакета выхода от DUT
    );

    // Генерация тактового сигнала
    initial begin                 // Начало initial блока для генерации clock
        aclk = 0;                 // Инициализация clock в 0
        forever #5 aclk = ~aclk;  // Бесконечный цикл: инвертировать clock каждые 5 единиц времени (период 10)
    end

    // Основной тестовый процесс
    initial begin                 // Начало основного initial блока для тестового процесса
        // Инициализация сигналов и переменных
        aresetn = 0;              // Установка сброса в активное состояние (low)
        s_axis_tvalid = 0;        // Сигнал валидности входа в неактивное состояние
        s_axis_tlast = 0;         // Сигнал последнего пакета входа в неактивное состояние
        m_axis_tready = 1;        // Сигнал готовности выхода в активное состояние (готов принимать данные)
        received_result = 128'b0; // Обнуление регистра полученного результата
        test_num = 0;             // Инициализация номера теста в 0
        bit_idx = 0;              // Инициализация индекса в bits в 0
        end_of_file = 0;          // Сброс флага конца файла
        success_count = 0;        // Обнуление счетчика успешных тестов
        fail_count = 0;           // Обнуление счетчика неуспешных тестов
        #10 aresetn = 1;          // Задержка 10 единиц времени, затем деактивация сброса (high)

        // Открытие файла с тестовыми векторами
        fd = $fopen("sequence.txt", "r");  // Открытие файла sequence.txt для чтения, сохранение дескриптора в fd
        if (fd == 0) begin        // Проверка, успешно ли открылся файл
            $display("Не удалось открыть файл sequence.txt");  // Вывод сообщения об ошибке, если файл не открылся
            $finish;              // Завершение симуляции при ошибке открытия файла
        end

        // Чтение и обработка тестов
        while (!end_of_file) begin  // Цикл чтения из файла до достижения конца
            char = $fgetc(fd);    // Чтение следующего символа из файла в char
            if (char == -1) begin // Проверка на конец файла (EOF возвращает -1)
                if (bit_idx > 0) begin  // Если в bits накопилось меньше 768 битов, но больше 0
                    $display("Внимание: тест длиной %0d битов не обработан (меньше 768 бит)", bit_idx);  // Вывод предупреждения о неполном тесте
                end
                end_of_file = 1;  // Установка флага конца файла
            end else if (char == "0" || char == "1") begin  // Проверка, является ли символ '0' или '1' (битом)
                bits[bit_idx] = (char == "1");  // Запись бита в массив bits (1 если '1', 0 если '0')
                bit_idx = bit_idx + 1;  // Инкремент индекса в bits
                if (bit_idx == 768) begin  // Проверка, накопилось ли ровно 768 битов (полный тест)
                    test_num = test_num + 1;  // Инкремент номера теста
                    $display("Тест %0d:", test_num);  // Вывод номера текущего теста

                    // Разделение на входную последовательность и эталонный результат
                    for (i = 0; i < 640; i = i + 1) begin  // Цикл копирования первых 640 битов в bit_sequence
                        bit_sequence[i] = bits[i];  // Копирование бита из bits в bit_sequence
                    end
                    for (i = 0; i < 128; i = i + 1) begin  // Цикл копирования следующих 128 битов в expected_result_bits
                        expected_result_bits[i] = bits[640 + i];  // Копирование бита из bits в expected_result_bits
                    end

                    // Передача входных данных в DUT
                    for (i = 0; i < 640; i = i + 1) begin  // Цикл передачи 640 битов по одному в DUT
                        @(posedge aclk);  // Ожидание положительного фронта clock
                        while (!s_axis_tready) begin  // Цикл ожидания, пока DUT не готов принять данные
                            @(posedge aclk);  // Ожидание следующего положительного фронта clock
                        end
                        s_axis_tdata = bit_sequence[i];  // Установка текущего бита на вход данных
                        s_axis_tvalid = 1;  // Активация сигнала валидности
                        s_axis_tlast = (i == 639);  // Установка tlast в 1 только для последнего бита
                    end
                    @(posedge aclk);  // Ожидание следующего clock после передачи
                    s_axis_tvalid = 0;  // Деактивация сигнала валидности
                    s_axis_tlast = 0;   // Деактивация сигнала последнего пакета

                    // Получение результата от DUT
                    bit_count = 0;      // Обнуление счетчика полученных битов
                    received_result = 128'b0;  // Обнуление регистра полученного результата
                    while (bit_count < 128) begin  // Цикл получения 128 битов от DUT
                        @(posedge aclk);  // Ожидание положительного фронта clock
                        if (m_axis_tvalid && m_axis_tready) begin  // Проверка, валидны ли данные и готов ли прием
                            received_result[bit_count] = m_axis_tdata;  // Запись бита в received_result
                            bit_count = bit_count + 1;  // Инкремент счетчика битов
                        end
                    end

                    // Сравнение и вывод результата
                    $display("  Получено: %b", received_result);  // Вывод полученного результата в бинарном виде
                    $display("  Ожидалось: %b", expected_result_bits); // Вывод ожидаемого результата в бинарном виде
                    if (received_result === expected_result_bits) begin  // Сравнение полученного и ожидаемого
                        $display("  Результат: УСПЕХ");  // Вывод успеха, если совпадают
                        success_count = success_count + 1;  // Инкремент счетчика успехов
                    end else begin
                        $display("  Результат: ОШИБКА");  // Вывод ошибки, если не совпадают
                        fail_count = fail_count + 1;  // Инкремент счетчика ошибок
                    end

                    // Сброс индекса для следующего теста
                    bit_idx = 0;  // Сброс индекса в bits для следующего теста
                end
            end
            
        end

        // Завершение и вывод статистики
        $fclose(fd);              // Закрытие файла по дескриптору fd
        $display("Все тесты завершены.");  // Вывод сообщения о завершении всех тестов
        $display("Итого: успешных тестов = %0d, неуспешных = %0d, всего = %0d", success_count, fail_count, test_num);  // Вывод статистики тестов
        $finish;                  // Завершение симуляции
    end

endmodule