// Модуль для генерации матрицы Pg путём циклических сдвигов базовых строк.
// Вход: 20 базовых строк (по 128 бит) из файла.
// Выход: Последовательно генерирует 640 строк (20 базовых x 32 сдвига каждая).
// На каждом такте с en=1 сдвигает текущую строку или переходит к следующей базовой.

module shift_register_processor (
    input clk,                  // Тактовый сигнал: .
    input rst,                  // Сброс
    input en,                   // Разрешение: 1 = генерировать следующую строку на этом такте.
    output wire [127:0] out_row, // Выходная строка: 128 бит
    output reg valid            // Валидность: 1 = out_row готова и актуальна.
);

    // Внутренние переменные:
    reg [31:0] sr0, sr1, sr2, sr3;  // 4 сдвиговых регистра по 32 бита: вместе формируют 128-битную строку.
                                    
    reg [127:0] base_rows [0:19];   // Массив: 20 базовых строк (каждая 128 бит), загруженных из файла.
                                    
    reg [4:0] base_idx;             // Счётчик базовых строк: 0-19, показывает, какая базовая строка сейчас обрабатывается.
    reg [4:0] shift_cnt;            // Счётчик сдвигов: 0-31, сколько раз мы сдвинули текущую базовую строку.

    
    // Загружает базовые строки из текстового файла (формат: 20 строк, каждая - 128 символов ).
    initial begin
        $readmemb("base_rows.txt", base_rows);  
    end

    
    
    assign out_row = {sr0, sr1, sr2, sr3};  // склеивание в один вектор.

    // Основная последовательная логика: Реагирует на такт (posedge clk) или сброс (posedge rst).
    // Здесь вся "магия" - обновление регистров и счётчиков.
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            // Сброс: Возвращаем всё в начальное состояние.
        
            base_idx <= 0;              // Начинаем с базовой строки №0.
            shift_cnt <= 0;             // Нет сдвигов пока.
            valid <= 0;                 // Выход не валиден (ещё ничего не сгенерировано).
            // Загружаем первую базовую строку в регистры:
            // Разбиваем 128 бит на 4 части по 32 бита для удобства сдвигов.
            sr0 <= base_rows[0][127:96];  // Старшие 32 бита (позиции 127 downto 96).
            sr1 <= base_rows[0][95:64];   // Следующие 32 (95 downto 64).
            sr2 <= base_rows[0][63:32];   // Ещё 32 (63 downto 32).
            sr3 <= base_rows[0][31:0];    // Младшие 32 (31 downto 0).
        end else if (en) begin
            // Если en=1: Генерируем следующую строку.
            // Это основной режим работы - на каждом таком такте выдаём новую строку.
            valid <= 1;                 // Теперь out_row валидна (можно использовать).

            // Проверяем, закончили ли сдвиги для текущей базовой строки.
            if (shift_cnt == 31) begin  // 31 - значит, сделали 31 сдвиг (всего 32 варианта: 0 + 31 сдвиг).
                if (base_idx < 19) begin  // Если не последняя базовая строка (19 - последняя).
                    // Переходим к следующей базовой строке:
                    // Загружаем её в регистры (как при сбросе, но для base_idx+1).
                    sr0 <= base_rows[base_idx + 1][127:96];
                    sr1 <= base_rows[base_idx + 1][95:64];
                    sr2 <= base_rows[base_idx + 1][63:32];
                    sr3 <= base_rows[base_idx + 1][31:0];
                    base_idx <= base_idx + 1;  // Увеличиваем индекс базовой строки.
                end
                shift_cnt <= 0;            // Сбрасываем счётчик сдвигов для новой базовой.
            end else begin
                // Если сдвиги не закончены: Делаем циклический сдвиг вправо на 1 бит.
                // Формула: (srX >> 1) - сдвиг вправо (младший бит уходит).
                // | (srX << 31) - OR с сдвигом влево: младший бит возвращается в старший? (циклически).
                // Это как круг: биты крутятся по кругу.
                sr0 <= (sr0 >> 1) | (sr0 << 31);
                sr1 <= (sr1 >> 1) | (sr1 << 31);
                sr2 <= (sr2 >> 1) | (sr2 << 31);
                sr3 <= (sr3 >> 1) | (sr3 << 31);
                shift_cnt <= shift_cnt + 1;  // Увеличиваем счётчик сдвигов.
            end
        end else begin
            // Если en=0: Ничего не делаем, стоим на месте.
            // Это "пауза" - ждём следующего en=1.
            valid <= 0;                 // Выход не валиден (не обновлялся).
        end
    end
endmodule