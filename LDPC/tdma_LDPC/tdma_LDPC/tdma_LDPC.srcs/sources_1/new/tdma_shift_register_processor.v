// Модуль для генерации матрицы Pg путём циклических сдвигов базовых строк.
// Вход: 20 базовых строк (по 128 бит) из файла.
// Выход: Последовательно генерирует 640 строк (20 базовых x 32 сдвига каждая).
// На каждом такте с en=1 сдвигает текущую строку или переходит к следующей базовой.


module tdma_shift_register_processor (
    input clk,                  // Тактовый сигнал: .
    input rst,                  // Сброс
    input en,                   // Разрешение: 1 = генерировать следующую строку на этом такте.
    output wire [127:0] out_row, // Выходная строка: 128 бит
    output reg valid            // Валидность: 1 = out_row готова и актуальна.
);

    // Внутренние переменные:
    reg [31:0] sr0, sr1, sr2, sr3;  // 4 сдвиговых регистра по 32 бита: вместе формируют 128-битную строку.

    //(* rom_style = "distributed" *)                                    
    reg [127:0] base_rows [0:19];   // Массив: 20 базовых строк (каждая 128 бит), загруженных из файла.
                                    
    reg [4:0] base_idx;             // Счётчик базовых строк: 0-19, показывает, какая базовая строка сейчас обрабатывается.
    reg [4:0] shift_cnt;            // Счётчик сдвигов: 0-31, сколько раз мы сдвинули текущую базовую строку.

    initial begin
        //$readmemb("base_rows.txt", base_rows);  // Перед прошивкой изменить на const или Rom
    end

    
    
    assign out_row = {sr0, sr1, sr2, sr3};  // склеивание в один вектор. (4 регистра по 32 строки , склеивание в один вектор 128 бит )

    // Основная последовательная логика: Реагирует на такт (posedge clk) или сброс (posedge rst).
    // Здесь вся "магия" - обновление регистров и счётчиков.
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            // Сброс: Возвращаем всё в начальное состояние.
            base_rows[0]  <= 128'b10000000000000011000000000000000100000100000000000000110000000000000001000000001100001100000000000000010000000001000011000000000;
            base_rows[1]  <= 128'b00000100000000000000000010000010000010000001000000000000100000100000110000010000000000000000001000001000000100000000000000000010;
            base_rows[2]  <= 128'b00000100000000101000000000000000000000000001001000001010000000000000010000010000100010100000000000000000000100001000101000000000;
            base_rows[3]  <= 128'b00000000000000000000100000010001010001000000000000000000001000000100010000000000000000000011000101000100000000000000000000110000;
            base_rows[4]  <= 128'b00000000001000000101000000000000000000000000000011000001010000000000000000100000100000010100000000000000000000001000000101000000;
            base_rows[5]  <= 128'b00000000000000000100100000000001000001000000000000000001001000010000010000000000000010010010000000000100000000000000100100100000;
            base_rows[6]  <= 128'b00000000000000000000000001000000000000000000000000000000000000010000000000000000000000000100100100000000000000000000000000001001;
            base_rows[7]  <= 128'b00100010000000000000000000000100001100001000100000000000000000000001000010001000000000000000010000010000100010000000000000000100;
            base_rows[8]  <= 128'b00001000000000000100001000000100000110000010000000000001000010000001000000100000000000110000110000010000001000000000000100001100;
            base_rows[9]  <= 128'b00000000000000000000000010100010100010000000000000000000000000001000100000000000000000001010001010001000000000000000000000100010;
            base_rows[10] <= 128'b00101000000000010001000000000000000010001010000000000100010000000010000010100001000001000100000000000000101000010000010001000000;
            base_rows[11] <= 128'b00100000000010010000000001000000000000001000000100100100000000010010000010001000001001000000000100100000100000000010010000000001;
            base_rows[12] <= 128'b00000000000000000000000100001000001001000000000000000000000001000010010000000000000000010000010000100000000000000000000100000100;
            base_rows[13] <= 128'b00100000010000000000010000000100000100001000000100000100000100000011000010000001000000000001010000110000100000010000000000010000;
            base_rows[14] <= 128'b00001000000001000000000000001001001001000010000000010000000000010010110000100100000100000000000000100100001001000001000000000000;
            base_rows[15] <= 128'b10000010100000000000001000000000100000100000101000000000000010000000000000001010000000100000100000000010000010100000001000001000;
            base_rows[16] <= 128'b10001000000010000000100000000000000000100010000000101000001000000000101000101000001000000010000000001010001000000010000000100000;
            base_rows[17] <= 128'b00110000000000000010000000100000100000001100000000000000101000001011000011000000000000001000000010100000110000000000000010000000;
            base_rows[18] <= 128'b00000000001000001000000000000101000101000000000010000010000000010001010000100000100000100000010000010100000000001000001000000100;
            base_rows[19] <= 128'b10000001001000000000000000010000010000110000010010000000000000000100001000100100100000000001000001000010001001001000000000000000;
            
            base_idx <= 0;              // Начинаем с базовой строки №0.
            shift_cnt <= 0;             // Нет сдвигов пока.
            valid <= 0;                 // Выход не валиден (ещё ничего не сгенерировано).
            // Загружаем первую базовую строку в регистры:
            // Разбиваем 128 бит на 4 части по 32 бита для удобства сдвигов.
            sr0 <= base_rows[0][127:96];  // Старшие 32 бита (позиции 127 downto 96).
            sr1 <= base_rows[0][95:64];   // Следующие 32 (95 downto 64).
            sr2 <= base_rows[0][63:32];   // Ещё 32 (63 downto 32).
            sr3 <= base_rows[0][31:0];    // Младшие 32 (31 downto 0).
        end else if (en) begin
            // Если en=1: Генерируем следующую строку.
            // Это основной режим работы - на каждом таком такте выдаём новую строку.
            valid <= 1;                 // Теперь out_row валидна (можно использовать).

            // Проверяем, закончили ли сдвиги для текущей базовой строки.
            if (shift_cnt == 31) begin  // 31 - значит, сделали 31 сдвиг (всего 32 варианта: 0 + 31 сдвиг).
                if (base_idx < 19) begin  // Если не последняя базовая строка (19 - последняя).
                    // Переходим к следующей базовой строке:
                    // Загружаем её в регистры (как при сбросе, но для base_idx+1).
                    sr0 <= base_rows[base_idx + 1][127:96];
                    sr1 <= base_rows[base_idx + 1][95:64];
                    sr2 <= base_rows[base_idx + 1][63:32];
                    sr3 <= base_rows[base_idx + 1][31:0];
                    base_idx <= base_idx + 1;  // Увеличиваем индекс базовой строки.
                end
                shift_cnt <= 0;            // Сбрасываем счётчик сдвигов для новой базовой.
            end else begin
                // Если сдвиги не закончены: Делаем циклический сдвиг вправо на 1 бит.
                // сдвиг вправо (младший бит уходит).
                // биты крутятся по кругу.
                sr0 <= (sr0 >> 1) | (sr0 << 31);
                sr1 <= (sr1 >> 1) | (sr1 << 31);
                sr2 <= (sr2 >> 1) | (sr2 << 31);
                sr3 <= (sr3 >> 1) | (sr3 << 31);
                shift_cnt <= shift_cnt + 1;  // Увеличиваем счётчик сдвигов.
            end
        end else begin
            // Если en=0: Ничего не делаем, стоим на месте.
            // Это "пауза" - ждём следующего en=1.
            valid <= 0;                 // Выход не валиден (не обновлялся).
        end
    end
endmodule